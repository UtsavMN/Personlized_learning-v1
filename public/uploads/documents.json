[
  {
    "id": "doc-1768120775481",
    "filename": "IPC - 4.2  4.3 (1).pdf",
    "storedFilename": "1768120775481-unix.pdf",
    "uploadDate": "2026-01-11T08:39:35.493Z",
    "mimeType": "application/pdf",
    "fileSize": 15618843,
    "storageLocation": "local-filesystem",
    "title": "unix",
    "description": "its module idk",
    "content": "\n\n \n \n \n4.2 -NTERPROCESS \nCOMMUNICATION \n \nOverview of IPC Methods \n1. Pipes \n2. Popen and pclose Functions \n3. Coprocesses \n4. FIFOs \n5. System V IPC \n6. Message Queues \n7. Semaphores \n \nINTRODUCTION \nIPC  enables one   application to  control another application, and  for \nseveral applications to share the same data without interfering with one \nanother. IPC   is required in all  multiprocessing systems, but  it is not \ngenerally supported by single-process operating systems. \nThe   various forms    of  IPC   that   are  supported on  a  UNIX    system     are  as \nfollows : \n1) Half duplex Pipes \n2) FIFO’s \n3) Full duplex Pipes \n4) Named full duplex Pipes \n5) Message queues \n6) Shared memory \n7) Semaphores \n8) Sockets \n9) STREAMS \n \nThe first seven forms of IPC are usually restricted to IPC between processes \non the same host. \nThe   final   two   i.e.   Sockets and STREAMS are the   only  two   that   are \ngenerally supported for IPC between processes on different hosts. \n \n1. PIPES   \n \nPipes     are   the   oldest    form    of  UNIX    System IPC.    Pipes    have   two \nlimitations. \nHistorically, they   have   been   half   duplex    (i.e.,   data   flows    in only  one \ndirection). \nPipes can be used only between processes that have a common ancestor. \nNormally, a pipe is created by a process, that process calls fork, and \nthe pipe is used between the parent and the child. \n\n#include<unistd.h>\nint        pipe(intfiledes[2]);\nReturns: 0 if OK, 1onerror.\nA pipe iscreated by calling the pipe function. \nTwo   file descriptorsarereturned through the  f i l e d e s  argument: \nfiledes[0]is open   f o r     reading, andfiledes[1]is open forwriting.\nThe output offiledes[1]is the input forfiledes[0].\nTwo  waystopicture a half-duplex pipeare shown inFigure 1.\nThe left half of the figure shows the two ends of the pipeconnected\nin a singleprocess.The right half of the figure emphasizesthat  the \ndata in the pipeflows through the kernel. \nFigure 1. Twowaystoview a half-duplex \npipe\nA pipe in a single processis next touseless.\nNormally, theprocessthat  calls  pipe then calls fork, creatingan IPC\nchannel from the parent to the child or viceversa. Figure 2 showsthis\nscenario.\nFigure 2 Half-duplex pipeafter a fork\nWhat happens after the fork depends on which direction of data flow we \nw a n t .\nFor a pipe from the parent to the child, the parent closes the read \nend of the pipe (fd[0]), and the child closes the write end (fd[1]). \nFigure 3 shows the resulting arrangement of descriptors.\n\nFigure 3 Pipefrom parent tochild\nFor a pipe from the childto the  parent, the parent closesfd[1], and the\nchild closes fd[0]. When one end ofa pipe isclosed, the following two\nrules apply. If we read from a pipe whose write end has been closed, \nread returns 0 to indicate an  end  of  file after all  the data has been\nread.\nIf we write to a pipe whose read end has been closed, the signal \nSIGPIPE is generated. If we eitherignore the signal or catch it and \nreturn from the signal handler, write returns 1 with errno set \nto EPIPE.\nPROGRAM: shows the code to create a pipe between a parent and itschild and \nto send data down the pipe. \n#\ni\nn\nc\nl\nu\nd\ne\n\"\na\np\nu\ne\n.\nh\n\"\ni\nn\nt\nm\na\ni\nn\n(\nv\no\ni\nd\n) \n{ \n\n \n \nint n; \nint fd[2]; \npid_t pid; \nchar line[MAXLINE]; \n \ni\nf\n(\np\ni\np\ne\n(\nf\nd\n)\n<\n0\n)\ne\nr\nr\n_\ns\ny\ns\n(\n\"\np\ni\np\ne\ne\nr\nr\no\nr\n\"\n)\n; \ni\nf\n(\n(\np\ni\nd\n=\nf\no\nr\nk\n(\n)\n\n \n \n)\n<\n0\n)\n{\ne\nr\nr\n_\ns\ny\ns\n(\n\"\nf\no\nr\nk\ne\nr\nr\no\nr\n\"\n)\n; \n} \ne\nl\ns\ne\ni\nf\n(\np\ni\nd\n>\n0\n)\n{\n /* parent */ close(fd[0]); \nwrite(fd[1], \"hello world\\n\", 12); \n} else { /* \nc\nh\ni\nl\nd\n \n*\n/\n \n\n \n \nc\nl\no\ns\ne\n(\nf\nd\n[\n1\n]\n)\n;\nn\n=\nr\ne\na\nd\n(\nf\nd\n[\n0\n]\n,\nl\ni\nn\ne\n,\nM\nA\nX\nL\nI\nN\nE\n)\n; \nw\nr\ni\nt\ne\n(\nS\nT\nD\nO\nU\nT\n_\nF\nI\nL\nE\nN\n\nO\n,\nl\ni\nn\ne\n,\nn\n)\n; \n} \nexit(0); \n} \n2. popenA N DpcloseFUNCTIONS\nSince a common operation is to create a pipe to another process, to \neither read its output or send it input, the standardI/O library has \nhistorically provided the popen and pclose functions. \nThese two functions handle all the dirty work that we've been doing \nourselves: creating a pipe, forking achild, closing the unused ends \nof the pipe, executing a shell to run the command, and waiting for \nthe commandto terminate.\nThe  functionpopendoes a fork and execto execute the cmdstring, \nand returns a standard I/Ofile pointer. \nIftype    is\"    r    \"    ,           thef i l e     pointer is connected to the standard output of \ncmdstring\nFigure 4  R e s u l t  of fp           = popen(cmdstring,\n\"r\") \nIf type is \"w\", thefile pointer isconnectedto the standard input of \ncmdstring, as shown: \n#include<stdio.h>\nFILE*popen(constchar*cmdstring,constchar*type);\nR    e    t    u    r    n    s    :       f  i  l  e   pointer if OK,NULLo  n   e  r  r  o  r\nint   pclose(FILE*fp);\nReturns:terminationstatusofcmdstring,or1 onerror\n\nFigure 5 Result of fp = popen(cmdstring,\n\"   w   \"   )    \n3. COPROCESSES\nA   U N I Xsystemfilter  is a program that readsfrom  standard input and \nwrites   to standard output. \nF   i   l   t   e   r   s      are       normallyconnectedlinearlyinshell  pipelines.\nA    filter   becomes a coprocessw h e n      t   h   e         same   program generates\nthe filter's input and reads the filter's output. \nA coprocessnormally runs inthe background from a shell, and its\nstandard input    and  standard output are  connectedto   another \nprogram using a pipe. \nThe   process createstwo   pipes:     one is  the   standard input    of  the \ncoprocess, and  the   other   is  the   standard output of  the   coprocess. \nFigure 6 showsthis arrangement.\nFigure 6. Driving a coprocess by writingi   t   s    standard input and reading \nits standard output\nProgram: Simple filter to add two numbers\n#\ni\nn\nc\nl\nu\nd\ne\n\"\na\np\nu\ne\n.\nh\n\"\ni\nn\n\n \n \n#include <sys/stat.h> \nint mkfifo(const char *pathname, mode_t mode); \nReturns: 0 if OK, -1 on error \n= \nstrlen(\nline); \nif \n(write(S\nTDOUT_FI\nLENO, \nline, n) \n!= n) \nerr_sys(\n\"write \nerror\"); \n} else { \nif (write(STDOUT_FILENO, \n\"invalid args\\n\", 13) \n!= 13) err_sys(\"write \nerror\"); \n} \n} \nexit(0); \n} \n \n4.  FIFOs \nFIFOs are sometimes called named pipes. Pipes can be used \nonly between related processes when a common ancestor has \ncreated the pipe. \n \nOnce we have used mkfifo to create a FIFO, we open it using open. When \nwe   open   a  FIFO, the   nonblocking flag    (O_NONBLOCK) affects what \nhappens. \nIn  the   normal case   (O_NONBLOCK not   specified), an  open   for \nread-only blocks until    some    other    process opens     the   FIFO    for \nwriting. Similarly, an open for write-only blocks until some other \nprocess opens the FIFO for reading. \nIf  O_NONBLOCK is  specified, an  open   for   read-only returns \nimmediately. But an open for write-only returns 1 with errno set to \nENXIOif no process has the FIFO open for reading. \n \nThere are two uses for FIFOs. \nFIFOs are used by shell commands to pass data from one shell \npipeline to  another without creating intermediate temporary \nfiles. \nFIFOs are used as rendezvous points in client-server applications \nto pass data between the clients andthe servers. \nExample Using FIFOs to Duplicate Output Streams \n \n\n \n \nF   I   F   O   s    can be   used    t   o         duplicate a n     output stream i   n         a series    of  shell \ncommands. \nThis    prevents writing the   data    to  an   intermediate disk   file. \nConsider a  procedure that   needs    toprocess a filtered input stream \ntwice. Figure shows this arrangement. \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nFIGURE :     Procedure that processes a filtered \ninput stream twice \n \nWith a FIFO and the UNIX program tee(1), we can accomplish this \nprocedure without using a temporary file. (The tee program copies its \nstandard input to both its standard output and to the file named on its \ncommand line.) \n \nm\nk\nf\ni\nf\no\n \nf\ni\nf\no\n1\n \np\nr\no\ng\n3 \n< fifo1 & \n \nprog1 < infile | tee fifo1 | prog2 \n \n \nWe create the FIFO and then start prog3 in the background, reading \nfrom the FIFO. We then start prog1 and use tee to send its input to \nboth the FIFO and prog2. Figure shows the process arrangement. \n \n \n\nFIGURE : Using   a FIFO and  tee  to send  a stream to two  different \nprocesses\nExample Client-Server Communication Using a FIFO \nFIFO’s can be used to send data between a client and a server. If we \nhave    a    server    that   is contacted by numerous clients, each client can \nwrite its request to a well-known FIFO that the server creates. Since \nthere are multiple writers for the FIFO, the requests sent by the clients \nto the server need to be less than PIPE_BUF bytes in size. \nThis    prevents any   interleaving of  the   client    writes. The   problem in \nusing   FIFOs for  this   type    of  client    server    communication is  how    to \nsend repliesback from the server to each client.\nA single FIFO can’t be used, as the clients would never know when to \nread their response versus responses for other clients. One solution is \nfor each client to send its process ID with the request. The server then \ncreates a unique FIFO for each client, using a pathname based on the \nclient’sprocess ID.\nFor   example, the   server can   create a  FIFO    with    the   name    /vtu/ \nser.XXXXX, where XXXXX is replaced with the client’s process ID. \nThis arrangement works, although it is impossible for the server to tell \nwhether aclient crashes. This causes the client-specific FIFOs to be \nleft in the file system.\nThe server also must catch SIGPIPE, since it’s possible for a client to \nsend a request and terminate before reading the response, leaving the \nclient-specific FIFO with one writer (the server) and no reader.\n\n \n \nFigure : Clients sending requests to a server \nusing a FIFO \n \n \n \nFigure: Client-server communication using \nFIFOs \n \n \n5.  System V IPC \n \n Identifiers and Keys \nEach    IPC  structure (message queue, semaphore, or   shared m   e   m   o   r   y    \nsegment) in the kernel is referred to by a non- negative integer identifier. \nThe identifier is an internal name for an IPC object. Cooperating processes \nneed an external naming scheme to be able to rendezvous using the same \nIPC  object. For this purpose, a n    I P C  object is associated with a key that \nacts as an external name. \nWhenever an IPC structure is being created, a key must be specified. The \ndata type of this key is the primitive system data type key_t, which is often \ndefined as a long integer in the header <sys/types.h>. This key is converted \ninto an identifier by the kernel. \nThere are various ways for a client and a server to rendezvous at the same IPC \nstructure. \nThe    server can   create a    new    IPC  structure by  specifying a    key   of \nIPC_PRIVATE and store the returned \nidentifier somewhere (such as a file) for the client to obtain. The \nkey   IPC_PRIVATE guarantees that the  server     creates a new    IPC \nstructure. The   disadvantage t   o         this   technique is t   h   a   t          file   system \noperations are required for the server to write the integer identifier \nto a file, and then for the clients to retrieve this identifier later. \nThe IPC_PRIVATE key is also used in a parent-child relationship. \nThe parent creates a new IPC structure specifying IPC_PRIVATE, \nand  the   resulting identifier is  then   available to the    child   after   the \nfork.    The    child can pass    the   identifier to  a  new    program as  an \nargument to one of the execfunctions. \n \nThe client and the server can agree on a key by defining the key in \n\n \n \n#include <sys/ipc.h> \nkey_t ftok(const char *path, int id); \nReturns: key if OK, (key_t)-1 on error \na common header, for example. The server then creates a new IPC \nstructure specifying this   key.   The   problem with    this   approach is \nthat it's possible for the key to already be associated with an IPC \nstructure, in  which case   the   get   function (msgget, semget, or \nshmget) returns an error. The server must handle this error, deleting \nthe existing IPC structure, and try to create it again. \nThe client and the server can agree on a pathname and project ID \n(the project ID is a character value between 0 and 255) and call the \nfunction ftok  to  convert these   two   values into   a  key.   This    key   is \nthen used in step 2. The only service provided by ftok is a way of \ngenerating a key from a pathname and project ID. \n \nThe path argument must refer to an existing file. Only the lower 8 bits \nof id are used when generating the key. \nThe   key   created by ftok  is  usually formed by taking parts    of  the \nst_dev and st_ino fields    in  the stat structure corresponding to the \ngiven pathname and combining them with the project ID. \nIf  two   pathnames refer    to  two   different files,    then   ftok  usually \nreturns two    different keys    for   the   two   pathnames. However, \nbecause both   i-node numbers and  keys    are  often   stored in  long \nintegers, there can be information loss creating a key. This means \nthat two different pathnames to different files can generate the same \nkey if the same project ID isused. \nPermission Structure \nXSI IPC associates an ipc_perm structure with each IPC structure. \nThis    structure defines the   permissions and  owner and  includes at \nleast the following members: \nstruct ipc_perm \n{ \nuid_t uid; /* owner's \neffective user id */ \ngid_t gid; /* owner's \neffective group id */ \nuid_t cuid; /* \ncreator's effective \nuser id */ gid_t cgid; \n/* creator's effective \ngroup id */ mode_t mode; \n/* access modes */ \n. \n. \n}; \nAll the fields are initialized when the IPC structure is created. At a \n\n \n \nlater time, we can modify the uid, gid, and   mode fields by calling \nmsgctl, semctl, or   shmctl. To  change these    values, the   calling \nprocess must    be   either    the   creator of   the   IPC  structure or   the \nsuperuser. Changing these    fields    is  similar to  calling chown or \nchmod for a file. \nPermission B   i   t    \nuser-read \n0400 \nuser-write (alter) \n0200 \ngroup-read \n0040 \ngroup-write (alter) \n0020 \nother-read \n0004 \nother-write (alter) \n0002 \nXSI IPC permissions \nAdvantages and Disadvantages \nA fundamental problem with XSI IPC( System V IPC ) is that the \nIPC structures are system wide and do not have a reference count. \nFor example, if we create a message queue, place some messages \non  the   queue, and  then   terminate, the   message queue and   its \ncontents are  not   deleted. They    remain in  the   system until \nspecifically read    or   deleted by  some    process calling msgrcv or \nmsgctl, by someone executing the   ipcrm(1) command, or  by the \nsystem being rebooted. Compare this    with   a  pipe,    which is \ncompletely removed when the   last   process to  reference it \nterminates. With a FIFO, although the name stays in the file system \nuntil explicitly removed, any data left in a FIFO is removed when \nthe last process to reference the FIFO terminates. \nAnother problem with XSI IPC ( System V IPC ) is that these IPC \nstructures are  not   known by names in  the   file   system. We can't \naccess them and modify their properties with the functions. Almost \na dozen new system calls (msgget, semop, shmat, and so on) were \nadded to the kernel to support these IPC objects. We can't see the \nIPC objects with an ls command, we can't remove them with the rm \ncommand, and we can't change their permissions with the chmod \ncommand. Instead, two new commands ipcs(1) and  ipcrm(1)were \nadded. \nSince these forms of IPC don't use file descriptors, we can't use the \nmultiplexed I/O functions (select and poll) with them. This makes it \nharder to use more than one of these IPC structures at a time or to \nuse   any  of   these    IPC    structures with    file   or   device I/O.    For \nexample, we can't have a server wait for a message to be placed on \none of two message queues without some form of busy wait loop. \n \n6.  MESSAGE QUEUES \n \nA    message queue     is a linked list   of  messages stored within the \n\n \n \n#include <sys/msg.h> \nint msgget(key_t key, int flag); \nReturns: message queue ID if OK, 1 on error \nkernel and identified by a message queue identifier. We'll call the \nmessage queue just a queue and its identifier a queue ID. \nA new queue is created or an existing queue opened by msgget. \nNew messages are added to the end of a queue by msgsnd. \nEvery message has   a  positive long  integer type    field,    a  non-\nnegative length, and  the   actual     data   bytes    (corresponding to  the \nlength), all of which are specified to msgsnd when the message is \nadded to a queue. \nMessages are fetched from a queue by msgrcv. We don't have to \nfetch    the   messages in  a  first-in, first-    out   order.    Instead, we   can \nfetch messages based on their type field. \nEach queue has the following msqid_dsstructure associated with it: \n \nstruct msqid_ds \n{ \nStruct ipc_perm msg_perm; \nmsgqnum_t   msg_qnum;   /* # \nof    messages on    queue */ msglen_t    \nmsg_qbytes; \n/* \nmax #        of         bytes on queue */ pid_t\n msg_lspid; \n/* pid \nof last msgsnd() */ \npid_t msg_lspid; \n/* \npid of last msgrcv() */time_t\n msg_stime; \n/* \nlast-msgsnd() time */ time_t\n msg_rtime; \n/* \nlast-msgrcv() time */ time_t\n msg_ctime; \n/* \nlast-change time */ \n. \n. \n \n}; \n \nThis structure defines the current status of the queue. \nmsgget \nThe first function normally called is msgget to either open an existing \nqueue or create a new queue. \n \nWhen a new queue is created, the following members of the msqid_ds structure \nare initialized. \n\n \n \n#include <sys/msg.h> \nint msgsnd(int msqid, const void *ptr, size_t nbytes, int flag); \nReturns: 0 if OK, -1 on error \nThe ipc_perm structure is initialized. The mode member of this \nstructure is set to the correspondingpermission bits of flag. \nmsg_qnum, msg_lspid, msg_lrpid, msg_stime, and msg_rtime are all set \nto 0. \nmsg_ctime is set to the current time. \nmsg_qbytes is set to the system limit. \nOn success, msgget returns the non-negative queue ID. This value is then used \nwith the other three message queue functions. \nMsgctl \nThe msgctl function performs various operations on a queue. \nThe cmd argument specifies the command to be performed on the queue \nspecified by msqid. \n \nMsgsnd \nData is placed onto a message queue by calling msgsnd. \nEach message is composed of a positive long integer type field, a non-\nnegative length (nbytes), and the actual data bytes (corresponding to \nthe length). Messages are always placed at the end of the queue. \nThe   ptr   argument points     to  a  long  integer that   contains the   positive \ninteger message type, and it is immediately followed by the message \ndata. (There is no message data if nbytes is 0.) If the largest message \nwe send is 512 bytes, we can define the following structure: \nstruct mymesg \n{ \nlong mtype; /* positive message type */ \nchar mtext[512]; /* message data, of length nbytes */ \n}; \n \nThe ptr argument is then a pointer to a mymesg structure. The message \ntype can be used by the receiver to fetch messages in an order other than \nfirst in, first out. \n \n \n \n \n \n \n#include <sys/msg.h> \nint msgctl(int msqid, int cmd, struct msqid_ds *buf ); \nReturns: 0 if OK, -1 o\n\n \n \n#include <sys/msg.h> \nssize_t msgrcv(int msqid, void *ptr, size_t nbytes, long type, int flag); \nReturns: size of data portion of message if OK, -1 on error. \nmsgrcv \nMessages are retrieved from a queue by msgrcv \nThe type argument lets us specify which message we want. \n \ntype == 0The first message on the queue is returned. \ntype > 0The first message on the queue whose message type equals type is returned. \ntype < 0The first message on the queue whose message type is the lowest value less \nthan or equal to the absolute value of type is returned. \n \n7.  SEMAPHORES \nA    semaphore is a    counter used   t   o        provide access t   o        a    shared data   object     f o r  \nmultiple processes. \nTo obtain a shared resource, a process needs to do the following: \n1.Test the semaphore that controls the resource. \n2.If the  value    of   the  semaphore is positive, the  process can   use   the \nresource. In this case, the process \ndecrements the semaphore value by 1, indicating that it has used one unit \nof the resource. \n3.Otherwise, if the value of the semaphore is 0, the process goes \nto sleep until the semaphore value is greater than 0. When the \nprocess wakes up, it returns to step 1. \n \nWhen     a  process is  done    with   a  shared resource that   is  controlled by a \nsemaphore, the   semaphore value     is  incremented by  1.  If  any  other \nprocesses are asleep, waiting for the semaphore, they are awakened. \nA common form of semaphore is called a binary semaphore. It controls a \nsingle     resource, and  i   t   s         value    i   s        initialized to 1.  In general, however, a  \nsemaphore can be   initialized t   o         any positive value, with the  value \nindicating how many units of the shared resource are available for sharing. \nX S I     semaphores are,   unfortunately, m   o   r   e          complicated than   this.    Three \nfeatures contribute to this unnecessary complication. \n1.A semaphore is not simply a single non-negative value. Instead, we \nhave    to define a semaphore as a        set       of  one   or       m   o   r   e          semaphore \nvalues. When    we create    a    semaphore, we        specify the  number of \nvalues in the set. \n2.The    creation of   a     semaphore (semget) is independent of   its \ninitialization (semctl). This         is a     fatal    f l a w ,       since   we cannot \natomically create a new semaphore set and initialize all the values \nin the set. \n\n \n \n3. Since   all   forms     of  XSI    IPC   remain in  existence even   when    no \nprocess is  using   them,    we   have    to  worry    about    a  program that \nterminates without releasing the semaphores it has been allocated. \nThe undo feature that we describe later is supposed to handle this. \nThe kernel maintains a semid_dsstructure for each semaphore set: \nstruct semid_ds \n{ \nstruct ipc_perm sem_perm; \nunsigned short sem_nsems; /* # \nof semaphores in set */ time_t\n sem_otime; /* last-semop() \ntime */ \ntime_t sem_ctime; /* last-change time */ \n. \n. \n. \n}\n; \nEach semaphore is represented by an anonymous structure containing at least \nthe following members: \nstruct \n{ \nunsigned short semval; /* \nsemaphore value, always >= 0 */ \npid_t sempid; /* pid for \nlast operation */ \nunsigned short semncnt; /* # processes \nawaiting semval>curval */unsigned short \nsemzcnt; /* # processes awaiting \nsemval==0 */ \n. \n. \n. \n}; \n \nsemget \nThe first function to call is semget to obtain a semaphore ID. \n \nWhen a new set is created, the following members of the semid_ds \nstructure are initialized. \nThe ipc_perm structure is initialized. The mode member of this structure is \nset to the correspondingpermission bits of flag. \nsem_otime is set to 0. \n#include <sys/sem.h> \nint semget(key_t key, int nsems, int flag); \nReturns: semaphore ID if OK, 1 o\n\n \n \n#include <sys/sem.h> \nint semop(int semid, struct sembuf semoparray[ ], size_t nops); \nReturns: 0 if OK, -1 on error. \nsem_ctime is set to the current time. \nsem_nsems is set to nsems. \nThe   number of  semaphores in  the   set   is  nsems. If  a  new    set   is  being \ncreated (typically in  the   server), we   must specify nsems. If  we   are \nreferencing an existing set (a client), we can specify nsems as 0. \n \nSemctl \n \nThe semctl function is the catchall for various semaphore operations. \nThe fourth argument is optional, depending on the command requested, and \nif present, is of type semun, a union of various command-specific arguments: \nunion semun \n{ \nintval; /* for SETVAL */ \nstruct semid_ds *buf; /* \nfor IPC_STAT and IPC_SET */ unsigned \nshort *array; /* \nfor GETALL and SETALL */ \n}; \n \n \nThe cmd argument specifies one of the above ten commands to be performed \non the set specified by semid. \n \nsemop \nThe    function semop atomically performs an         array    of operations on   a \nsemaphore set.\n \n \nThe semoparray argument is a pointer to an array of semaphore operations, \nrepresented by sembuf \nstructures: \nstruct sembuf \n{ \nunsigned short sem_num; /* member # in \nset (0, 1, ..., nsems-1) */ short sem_op; \n#include <sys/sem.h> \nint semctl(int semid, int semnum, int cmd,... /* union semun arg */); \n\n \n \n/* operation (negative, 0, or positive) \n*/ short sem_flg; /* IPC_NOWAIT, \nSEM_UNDO */ \n}; \n \nThe   nops    argument specifies the  number of  operations (elements) i   n         the \narray. \nThe    sem_op element operations are  values specifying the  amount by \nwhich the semaphore value is to be changed. \nIf sem_op is an integer greater than zero, semop adds the value to \nthe   corresponding semaphore element value     and  awakens all \nprocesses that are waiting for the element to increase. \nIf sem_op is 0 and the semaphore element value is not 0,  semop \nblocks the calling process (waiting for 0) and increments the count \nof processes waiting for a zero value of that element. \nIf sem_op is a negative     number, semop adds the sem_op value to \nthe corresponding semaphore element value provided that the result \nwould not   be   negative. If  the   operation would make    the   element \nvalue    negative, semop blocks the   process on   the   event    that   the \nsemaphore element value    increases. If  the   resulting value    is  0, \nsemop wakes the processes waiting for 0. \n \n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "contentPreview": "\n\n \n \n \n4.2 -NTERPROCESS \nCOMMUNICATION \n \nOverview of IPC Methods \n1. Pipes \n2. Popen and pclose Functions \n3. Coprocesses \n4. FIFOs \n5. System V IPC \n6. Message Queues \n7. Semaphores \n \nINTRODUCTION \nIPC  enables one   application to  control another application, and  for \nseveral applications to share the same data without interfering with one \nanother. IPC   is required in all  multiprocessing systems, but  it is not \ngenerally supported by single-process operating systems. \nThe   various fo"
  }
]